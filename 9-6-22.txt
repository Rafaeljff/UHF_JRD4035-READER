#include "Arduino.h"
#include "RFID_command.h"
#include <stdio.h>
#include <Wire.h>
#include <SPI.h>
#include <SD.h>
#include <FS.h>
#include <string.h>
#include<stdbool.h>
#include "RTClib.h"
#include "Arduino.h"
#include <WiFi.h>
#include <PubSubClient.h>
#include <HTTPClient.h>
#include <Adafruit_GFX.h>
#include <Adafruit_SSD1306.h>
#include <Keypad.h>
#include <LiquidCrystal_I2C.h>
#define SCREEN_WIDTH 128 // OLED display width, in pixels
#define SCREEN_HEIGHT 32 // OLED display height, in pixels

UHF_RFID RFID;

String comd = " ";
CardpropertiesInfo card;
ReadInfo card2;
ManyInfo cards;
SelectInfo Select;
CardInformationInfo Cardinformation;
QueryInfo Query;
ReadInfo Read;
TestInfo Test;
Adafruit_SSD1306 display = Adafruit_SSD1306(128, 32, &Wire);
LiquidCrystal_I2C lcd(0x27, 16, 2);
File myFile;
RTC_DS3231 rtc;
const int chipSelect = 5;

/*const char *ssid = "Vodafone-FD27C0";
 const char *password = "vodafone10";*/
/*const char *ssid = "labs";
const char *password = "robot1cA!ESTG";
const char *server_tag_main = "http://10.20.229.174:1880/tag_main";
const char *server_present_tags = "http://10.20.229.174:1880/present_tags";
const char *server_statebox = "http://10.20.229.174:1880/statebox";
const char *server_menu_select = "http://10.20.229.174:1880/buton";

*/

const char *ssid = "labs";
const char *password = "robot1cA!ESTG";
const char *server_tag_main = "http://10.20.228.54:1880/tag_main";
const char *server_present_tags = "http://10.20.228.54:1880/present_tags";
const char *server_statebox = "http://10.20.228.54:1880/statebox";
const char *server_menu_select = "http://10.20.228.54:1880/buton";





const char *adicionar_tag_andre="http://10.20.228.54:1880/pixota";
/*
 const char *server_tag_main = "http://192.168.1.72:1880/tag_main";
 const char *server_present_tags = "http://192.168.1.72:1880/present_tags";
 const char *server_statebox = "http://192.168.1.72:1880/statebox";
 String server_menu_select = "http://192.168.1.72:1880/buton";
 /*
 const char *server_tag_main = "http://10.20.228.194:1880/tag_main";
 const char *server_present_tags = "http://10.20.228.194:1880/present_tags";
 const char *server_statebox = "http://10.20.228.194:1880/statebox";
 String server_menu_select = "http://10.20.228.194:1880/buton";
 */
/*const char *server_tag_main = "http://10.20.228.130:1880/tag_main";
 const char *server_present_tags = "http://10.20.228.130:1880/present_tags";
 const char *server_statebox = "http://10.20.228.130:1880/statebox";
 String server_menu_select = "http://10.20.228.130:1880/buton";*/

//keyboard
const byte ROWS = 4; //four rows
const byte COLS = 4; //three columns
char keys[ROWS][COLS] = { { '1', '2', '3', '4' }, { '5', '6', '7', '8' }, { '9',
		'10', '11', '12' }, { '13', '14', '15', '16' }, };
byte rowPins[ROWS] = { 4, 0, 15, 32 }; //connect to the row pinouts of the kpd
byte colPins[COLS] = { 12, 14, 27, 26 }; //connect to the column pinouts of the kpd

Keypad keypad = Keypad(makeKeymap(keys), rowPins, colPins, ROWS, COLS);

int red_led = 25;
int green_led = 2;
int menu_changer = 13;
volatile byte state_led = LOW;

WiFiClient Wificlient;
PubSubClient client(Wificlient);
HTTPClient http;
int select_key = 0;
//ficheiro das tags
char filename_tags[] = "/taglist.CSV";
char filename_box_tag[] = "/boxlist.CSV";
char filename_registos[] = "/registos.CSV";
char filename_raw_registos[] = "/todos_registos.CSV";
String file1_tags[30];
String last_file1_tag;
int file_counter_1 = 0;
int lastpos_file1 = 0;
String file2_tags[30];
int file_counter_2 = 0;
int lastpos_file2 = 0;
String last_column;
String commands_str = { "\n1-Verificao de tags na caixa"
		"\n2-Inserir uma nova tag como tag de caixa"
		"\n3-inserir uma nova tag a uma caixa existente"
		"\n4-informacao da ultima verificacao " };

int count_non_registered = 0;
int count_registered = 0;
String global = "";
String all_present_tags = "";
String all_missing_tags = "";
String last_tag_main = "";
size_t size_tags;
volatile unsigned long ul;
volatile unsigned long millis_counter;
unsigned long previousMillis = 0;
int show_menu = 1;
int button_change = 1;
void setup() {
	Serial2.begin(115200, SERIAL_8N1, 16, 17); //16.17
	Serial.begin(115200);
	pinMode(menu_changer, INPUT);
	//attachInterrupt(menu_changer, menu_change, FALLING);
	RFID.Set_transmission_Power(2600);
	RFID.Set_the_Select_mode();
	RFID.Delay(100);
	RFID.Readcallback();
	RFID.clean_data();
	//lcd.begin();
	lcd.backlight();
	lcd.print("Second LCD!!");
	display.begin(SSD1306_SWITCHCAPVCC, 0x3C); // Address 0x3C for 128x32
	display.clearDisplay();
	display.setTextSize(2);
	display.setTextColor(SSD1306_WHITE);
	display.setCursor(0, 15);
	display.println("SMART LAB ");
	display.setCursor(0, 0);
	display.println("CHECKBOX");
	display.display();

	if (SD.begin(5))
		Serial.println("SD card is ready");

	if (!SD.begin(chipSelect))
		Serial.println("Card failed, or not present");

	pinMode(red_led, OUTPUT);
	pinMode(green_led, OUTPUT);

	rtc.begin();

	if (!rtc.begin()) {
		Serial.println("Couldn't find RTC");
		Serial.flush();
		while (1)
			delay(10);
	}

	WiFi.begin(ssid, password);
	Serial.println("Connecting to wifi...");
	while (WiFi.status() != WL_CONNECTED) {
		delay(500);
		Serial.print("still not connected to wifi");
	}

	Serial.print("Connected to WiFi network with IP Address: ");

	// Your Domain name with URL path or IP address with path
	// http.begin(Wificlient, serverName);

	ler_file_1();
	ler_file_2();

	/* Use 1st timer of 4 */
	/* 1 tick take 1/(80MHZ/80) = 1us so we set divider 80 and count up */

	//timer2 = timerBegin(0, 80, true);
	/* Attach onTimer function to our timer */

	//timerAttachInterrupt(timer2, &onTimer2, true);
	/* Set alarm to call onTimer function every second 1 tick is 1us
	 => 1 second is 1000000us */
	/* Repeat the alarm (third parameter) */

	//timerAlarmWrite(timer2,1000000, true);
	/* Start an alarm */

	delay(5000);
}

void IRAM_ATTR onTimer2() {
	state_led = !state_led;
	digitalWrite(red_led, state_led);

}
// The loop function is called in an endless loop
void loop() {

	Menu_main();

}
void Menu_main() {
	int selection = 0;
	unsigned long currentMillis = millis();

	if (currentMillis - previousMillis >= 3000) {

		digitalWrite(red_led, LOW);
		digitalWrite(green_led, LOW);
	}

	selection = menu_select_all();

	display.clearDisplay();
	display.setTextSize(0.5);
	display.setTextColor(SSD1306_WHITE);

	display.setCursor(0, 0);
	display.println("1-Verificacao");
	display.setCursor(0, 7);
	display.print("2-Adicionar tag caixa");
	display.setCursor(0, 14);
	display.print("3-Adicionar tag nova");
	display.setCursor(0, 21);
	display.print("4-info ultima verificacao");
	display.display();

	switch (selection) {
	case 1:
		func_verificar_tags();

		break;
	case 2:
		InserirBox_file_1();
		break;
	case 3:
		Inserir_tag_nova_();
		break;
	case 4:
		mostrar_leitura();
		break;
	case 5:
		write_sd();
		break;
	case 6:
send_tags();

		break;
	default:

		break;

	}
}

int User_menu_input() {

	if (!Serial.available()) {
		return 0;
	}
	if (Serial.available()) {
		int menu_select = Serial.parseInt();
		if (menu_select != 1 && menu_select != 2 && menu_select != 3
				&& menu_select != 4 && menu_select != 5 && menu_select != 6
				&& menu_select != 7) {
			Serial.println("opcao incorreta");
			return 0;
		} else {
			Serial.println("Menu selected: ");
			Serial.println(menu_select);
			return menu_select;
		}
	}
}

void func_verificar_tags() { //verifica se alguma tag lida corresponde a tags de uma caixa no cartao microsd

	show_menu = 1;
	int check = 0;
	String current_reading2[20];
	String current_reading[20];
	String tag_caixa;
	int count = 0;
	String caixas_string = "";
	global = "";
	all_present_tags = "";
	size_tags = 0;

	myFile = SD.open(filename_tags);

	if (myFile) {

		// read from the file until there's nothing else in it:
		Serial.print("\nlendo do cartao as tags que sao caixas ");
		while (myFile.available()) {

			current_reading2[count] = myFile.readStringUntil('\n,'); // para ler x
			caixas_string = caixas_string + current_reading2[count];
			Serial.print("\ncoluna ");
			Serial.print(count); // 00-99
			Serial.print(": ");
			Serial.print(current_reading2[count]);
			count++;

		}
		myFile.close();
	}

	cards = RFID.Multiple_polling_instructions(20);

	for (size_t i = 0; i < cards.len; i++) {

		current_reading[i] = cards.card[i]._EPC;

	}

	size_tags = cards.len;
	RFID.clean_data();
	Serial.print(
			"\n -------------------------- LEITURA DE VERIFICACAO CONCLUIDA------------------------ ");
	for (size_t i = 0; i < size_tags; i++) {

		current_reading[i] = current_reading[i].substring(19, 24);

		if (current_reading[i].length() == 5) {

			lcd.clear();
			display.clearDisplay();
			display.setTextSize(1);
			display.setTextColor(SSD1306_WHITE);
			display.setCursor(0, 0);
			display.print("tag lida:" + current_reading[i]);
			display.setCursor(0, 7);
			display.print(current_reading[i]);
			display.setCursor(0, 14);

			display.display();

		} else {

			display.clearDisplay();
			display.setTextSize(0.5);
			display.setTextColor(SSD1306_WHITE);
			display.setCursor(0, 0);
			display.print("nao foram detetadas");
			display.setCursor(0, 7);
			display.print("caixas na leitura");
			display.setCursor(0, 14);
			display.print("voltando para o menu");
			display.setCursor(0, 21);
			display.print("inicial");
			display.display();
			millis_counter = millis();
			for (ul = millis_counter; ul < millis_counter + 3000; ul = millis())
				;;
			return;

		}

		for (int j = 0; j < file_counter_1; j++) {

			if (current_reading[i] == file2_tags[j]
					|| current_reading[i] == file2_tags[file_counter_1]) {

				tag_caixa = current_reading[i];
				check = 1;

				//RFID.clean_data();
			} else if (current_reading[i] != current_reading2[j]
					&& (j == file_counter_1 - 1) && (i == size_tags - 1)
					&& check != 1) {
				Serial.print("\nTags detetadas nao sao caixas");

				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.print("tags detetadas");
				display.setCursor(0, 7);
				display.print("nao correspondem");
				display.setCursor(0, 14);
				display.print("a tags de");
				display.setCursor(0, 21);
				display.print("caixa");
				display.display();
				millis_counter = millis();
				for (ul = millis_counter; ul < millis_counter + 3000; ul =
						millis())
					;;

				display.clearDisplay();

				//RFID.clean_data();
			}

		}

	}

	if (check == 1) {
		scan_tags_row(tag_caixa, current_reading);

	}
	if (size_tags == 0) {

		display.clearDisplay();
		display.setTextSize(0.5);
		display.setTextColor(SSD1306_WHITE);
		display.setCursor(0, 0);
		display.print("Nao foram ");
		display.setCursor(0, 7);
		display.print("detetadas tags");
		display.setCursor(0, 14);
		display.print("no leitor");
		display.setCursor(0, 21);
		display.print("");
		display.display();
		display.clearDisplay();

		millis_counter = millis();
		for (ul = millis_counter; ul < millis_counter + 3000; ul = millis())
			;;
		Serial.println("\nreturn to menu");
		return;
	}

}

void scan_tags_row(String search_string, String current_reading_array[]) { // a partir de um ponteiro para uma determinada box tag que se encontra na primeira coluna, imprime o resto da linha com
// os id das tags associadas

	char *ptr;
	char char_array[5];
	int check = 0;
	int check2[20];
	int check3[20];
	int count2 = 0;
	int count3 = 0;
	int count = 1;

	String current_reading_2[30];
	String missing_tags[30];
	String present_tags[30];
	String main_tag;
	String reading;
	String current;
	String state;

	int missing_tag_counter = 0;
	int present_tag_counter = 0;
	last_tag_main = search_string;
	myFile = SD.open(filename_box_tag);
	main_tag = search_string + ",";
	main_tag.toCharArray(char_array, 8);

	if (myFile) {

		if (myFile.find(char_array)) {
			myFile.position();
			while (myFile.available()) {
				reading = myFile.readStringUntil('\n');

				Serial.print(current_reading_2[count]);

				if (myFile.find(",")) {
					count++;
					break;
				}
			}
		}
		myFile.close();
	} //parentises alterado 6/3
	char column[reading.length()];

	Serial.print(
			"\n\nTAGS no cartao que estao associadas a tag da caixa lida: ");
	Serial.print(search_string);
	Serial.print(":\n");
	Serial.print(reading);
	Serial.print("\n\n-------------------------------------------");

	reading.toCharArray(column, reading.length());
	ptr = strtok(column, ",");
	while (ptr != NULL) {
		current_reading_2[count2] = ptr;
		count2++;
		ptr = strtok(NULL, ",");
	}

	for (int i = 0; i < count2; i++) {
		check2[i] = 0;

		for (int j = 0; j < size_tags; j++) {

			if (current_reading_2[i] == current_reading_array[j]) {
				check2[i] = 1;
			}

		}
	}
	for (int y = 0; y < count2; y++) {
		if (check2[y] != 1) {
			check = 1;

			missing_tags[missing_tag_counter] = current_reading_2[y];
			missing_tag_counter++;
			Serial.print("\n tag:");
			Serial.print(current_reading_2[y]);
			Serial.print("nao presente na leitura");

		} else {
			if (current_reading_2[y] != search_string) {
				Serial.print("\n tag:");
				Serial.print(current_reading_2[y]);
				Serial.print("presente na leitura de caixa");

				present_tags[present_tag_counter] = current_reading_2[y];
				present_tag_counter++;
				all_present_tags = all_present_tags + ","
						+ current_reading_2[y];

			}
		}
	}

	Serial.print(all_present_tags);

	global =all_present_tags;
	if (check == 0) {

		Serial.print("\nESTADO:CAIXA COMPLETA");
		state = "Completa";
		digitalWrite(green_led, HIGH);

	} else if (check == 1) {
		state = "Incompleta";
		digitalWrite(red_led, HIGH);

		Serial.print("\nESTADO:CAIXA INCOMPLETA");
		Serial.print("\n tags em falta:");
		for (int k = 0; k < missing_tag_counter; k++) {
			all_missing_tags = all_missing_tags + "," + missing_tags[k];
			Serial.print(missing_tags[k]);
			Serial.print(" ");

		}
		Serial.print(" \n\n------------------------");
	}

	display.clearDisplay();
	display.setTextSize(1);
	display.setTextColor(SSD1306_WHITE);
	display.setCursor(0, 0);
	display.print("Caixa principal:");
	display.print(search_string);
	display.setCursor(0, 10);
	display.print("estado:");
	display.print(state);
	display.display();
	millis_counter = millis();
	for (ul = millis_counter; ul < millis_counter + 3000; ul = millis())
		;;
	Serial.println("\nreturn to menu");
	registo(search_string, present_tags, present_tag_counter, state);
	raw_registo(current_reading_array, search_string, state);

//myFile = SD.open(filename_box_tag, FILE_READ);

	for (int j = 0; j < cards.len; j++) {

		check3[j] = 0;
		for (int i = 0; i < count2; i++) {

			if (current_reading_array[j] == current_reading_2[i]) {
				check3[j] = 1;
			}

		}
		if (check3[j] == 0) {

			existing_tags(current_reading_array[j]);

		}

	}

	if (WiFi.status() == WL_CONNECTED) { //falta condicao de selecao

	 http.begin(server_tag_main);
	 //http.addHeader("tag_principal", "text/plain");
	 http.POST(search_string);
	 http.end();

	 http.begin(server_statebox);
	 //	http.addHeader("estado", "text/plain");
	 http.POST(state);
	 http.end();

	 http.begin(server_present_tags);
	 //http.addHeader("todas_tags", "text/plain");
	 http.POST(global);

	 http.end();

	 }
}

void existing_tags(String search_string) {
	int count = 0;
	String row_reading[30];
	String non_registered[10];
	String registered[10];
	String main_tags[5];
	String current_reading[30];
	String tag_main;
	char *ptr;
	char char_array[5];
	int check = 0;
	int count2 = 0;
	int check_main = 0;


	Serial.print("\n");

	myFile = SD.open(filename_box_tag, FILE_READ);

	if (myFile) {

		while (myFile.available()) {
			row_reading[count] = myFile.readStringUntil('\n');
			count++;
		}
		myFile.close();

		for (int counter = 0; counter < count; counter++) {
			count2 = 0;
			char column[row_reading[counter].length()];

			row_reading[counter].toCharArray(column,
					row_reading[counter].length());
			ptr = strtok(column, ",");
			while (ptr != NULL) {
				current_reading[count2] = ptr;
				count2++;
				ptr = strtok(NULL, ",");
			}

			for (int i = 0; i < count2; i++) {

				if (search_string == current_reading[i]) {
					check = 1;
					tag_main = current_reading[0];

				}
			}

		}

		if (search_string != tag_main) {

			if (check == 1) {

				Serial.print("\nA tag:");
				Serial.print(search_string);
				Serial.print(" esta registada no sistema e ");
				Serial.print("corresponde a caixa: ");
				Serial.print(tag_main);
				Serial.print("\n-------------------------------------------\n");
				global = global + "," + search_string;
			} else {

				Serial.print("\A tag: ");
				Serial.print(search_string);
				Serial.print("nao esta registada no sistema:  ");

				Serial.print("\n-------------------------------------------\n");

			}
		} else {

			Serial.print("A tag: ");
			Serial.print(search_string);
			Serial.print(" e uma tag associada a caixa");
			Serial.print("\n------------------------------------------\n");
		}
	}
}
void raw_registo(String present_tags[], String main, String state) {
	DateTime now = rtc.now();

	String last_reading;
	int file_counter = 0;
	int pos_reg = 0;
	myFile = SD.open(filename_raw_registos);

	if (myFile) {

		// read from the file until there's nothing else in it:
		//Serial.print("\nlendo do ficheiro1  as tags que sao caixas ");
		while (myFile.available()) {

			last_reading = myFile.readStringUntil(','); // para ler x

			if (last_reading.length() != 0) {
				pos_reg = myFile.position();

			} else
				pos_reg = 0;

			file_counter++;

		}
		myFile.close();
		myFile = SD.open(filename_raw_registos, FILE_WRITE);
		if (myFile) {
			if (myFile.seek(pos_reg)) {
				myFile.println("ESP32-modulo1");
				myFile.print(',');
				myFile.print(now.hour());
				myFile.print(":");
				myFile.print(now.minute());
				myFile.print(":");
				myFile.print(now.second());

				myFile.print(',');
				myFile.print(now.day());
				myFile.print("/");

				myFile.print(now.month());
				myFile.print("/");

				myFile.print(now.year());
				myFile.print(',');
				myFile.print("tags presentes:");
				for (int i; i < cards.len; i++) {
					myFile.print(present_tags[i]);
					myFile.print(',');

				}
				myFile.print(state);
				myFile.print('\n');

			}
			myFile.close();

		}
	}
}
void registo(String main, String present_tags[], int count, String state) {
	DateTime now = rtc.now();
	String file_registo[30];
	String last_reading;
	int file_counter = 0;
	int pos_reg;
	myFile = SD.open(filename_registos);

	if (myFile) {

		while (myFile.available()) {

			last_reading = myFile.readStringUntil(','); // para ler x

			if (last_reading.length() != 0) {
				pos_reg = myFile.position();

			} else
				pos_reg = 0;

			file_counter++;

		}
		myFile.close();

		myFile = SD.open(filename_registos, FILE_WRITE);

		if (myFile) {
			if (myFile.seek(pos_reg)) {
				//myFile.println('\n');
				myFile.println("ESP32-modulo1");
				myFile.print(',');
				myFile.print(now.hour());
				myFile.print(":");
				myFile.print(now.minute());
				myFile.print(":");
				myFile.print(now.second());

				myFile.print(',');
				myFile.print(now.day());
				myFile.print("/");

				myFile.print(now.month());
				myFile.print("/");

				myFile.print(now.year());
				myFile.print(',');

				myFile.print("Caixa-" + main);
				myFile.print(',');
				myFile.print("tags presentes:");
				for (int i; i < count; i++) {
					myFile.print(present_tags[i]);
					myFile.print(',');
				}
				myFile.print(state);
				myFile.close();

			}
		}

	}
}

String func_adicionar_novas_tags() {
	String current_reading;
	card = RFID.A_single_poll_of_instructions();
	current_reading = card._EPC;
	current_reading = current_reading.substring(19, 24);
	if (current_reading.length() != 0) {
		Serial.print(
				"\n --------------------------TAG LIDA------------------------ ");
		Serial.print(current_reading); // 00-99
		Serial.print(
				"\n -------------------------- FIM DA LEITURA------------------------ ");
		RFID.clean_data();
		return current_reading;
	}
	Serial.print(
			"\n -------------------------- TAG NAO LIDA------------------------ ");
	RFID.clean_data();
}

void ler_file_1() {

	myFile = SD.open(filename_tags);

	if (myFile) {

		// read from the file until there's nothing else in it:
		//Serial.print("\nlendo do ficheiro1  as tags que sao caixas ");
		while (myFile.available()) {

			file1_tags[file_counter_1] = myFile.readStringUntil(','); // para ler x

			if (file_counter_1 > 0
					&& file1_tags[file_counter_1].length() == 5) {

				lastpos_file1 = myFile.position();
				last_file1_tag = file1_tags[file_counter_1];
			}

			file_counter_1++;

		}
		myFile.close();
		Serial.print("\nlendo do cartao as tags que sao caixas");

		Serial.print("\nultima tag lida:");
		Serial.print(last_file1_tag);

		imprimir_file1();

	}

}
void update_file_1() {

	file_counter_1 = 0;
	myFile = SD.open(filename_tags);
	if (myFile) {

		// read from the file until there's nothing else in it:
		//Serial.print("\nlendo do ficheiro1  as tags que sao caixas ");
		while (myFile.available()) {

			file1_tags[file_counter_1] = myFile.readStringUntil(','); // para ler x

			if (file1_tags[file_counter_1].length() == 5) {

				lastpos_file1 = myFile.position();
			}

			file_counter_1++;

		}
		myFile.close();

	}
	return;
}
void InserirBox_file_1() {
	show_menu = 1;
	String current_reading = func_adicionar_novas_tags();
	char char_current_reading[6];
	current_reading.toCharArray(char_current_reading, 6);
	int check = 0;
	int check_componente = 0;
	if (current_reading.length() != 0) {
		myFile = SD.open(filename_box_tag);
		if (myFile) {
			if (myFile.find(char_current_reading))
				check_componente = 1;
			myFile.close();
		}

		for (int j = 0; j < file_counter_1; j++) {
			if (current_reading == file1_tags[j] && check != 1) {
				Serial.print(
						"\nTag ja inserida no sistema e corresponde a uma caixa ");
				check = 1;

				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.println("Tag lida:" + current_reading);

				display.setCursor(0, 7);
				display.print(" ja se encontra");

				display.setCursor(0, 14);
				display.print("registada no sistema");
				display.setCursor(0, 21);
				display.print("operacao cancelada!");
				display.display();

				millis_counter = millis();
				for (ul = millis_counter; ul < millis_counter + 2000; ul =
						millis())
					;;
				return;
			} else if (check_componente == 1 && check != 1
					&& (j == file_counter_1 - 1)) {

				Serial.print(
						"\nTag ja inserida no sistema e corresponde a um componente! ");
				check = 1;

				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.println("Tag lida:" + current_reading);

				display.setCursor(0, 7);
				display.print(" ja se encontra");

				display.setCursor(0, 14);
				display.print("registada no sistema");
				display.setCursor(0, 21);
				display.print("operacao cancelada!");
				display.display();
				millis_counter = millis();
				for (ul = millis_counter; ul < millis_counter + 2000; ul =
						millis())
					;;
				return;
			} else if (current_reading != file1_tags[j]
					&& (j == file_counter_1 - 1) && check != 1
					&& check_componente != 1) {

				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.println("Tag lida:" + current_reading);

				display.setCursor(0, 7);
				display.print(" Pretende registar");

				display.setCursor(0, 14);
				display.print("a tag como caixa??");
				display.setCursor(0, 21);
				display.print("1-SIm 2-Voltar ao menu");
				display.display();

				int escolha = 0;
				while (escolha != 1 || escolha != 2) {
					escolha = menu_select_all();
					if (escolha == 1 || escolha == 2) {
						break;
					}
				}
				if (escolha == 1) {

					myFile = SD.open(filename_tags, FILE_WRITE);
					if (myFile) {
						myFile.seek(lastpos_file1);

						myFile.print(',');
						myFile.print(current_reading);

						myFile.close();
						inserirBox_file_2(current_reading);
					}
					Serial.print("\nA tag lida:");
					Serial.print(current_reading);

					Serial.print("\nfoi registada como tag de caixa!");
					last_file1_tag = current_reading;
					display.clearDisplay();
					display.setTextSize(0.5);
					display.setTextColor(SSD1306_WHITE);
					display.setCursor(0, 0);
					display.println("A tag foi registada");

					display.setCursor(0, 7);
					display.print(" com sucesso!!");

					display.setCursor(0, 14);
					display.print("");
					display.setCursor(0, 21);
					display.print("");
					display.display();

					update_file_1();

					return;
				} else if (escolha == 2)

				{
					Serial.print("\nOperacao cancelada:");

					display.clearDisplay();
					display.setTextSize(0.5);
					display.setTextColor(SSD1306_WHITE);
					display.setCursor(0, 0);
					display.println("operacao cancelada pelo");

					display.setCursor(0, 7);
					display.print(" pelo utilizador");

					display.setCursor(0, 14);
					display.print("voltabdo para o menu");
					display.setCursor(0, 21);
					display.print("principal!!");
					display.display();
					millis_counter = millis();
					for (ul = millis_counter; ul < millis_counter + 3000; ul =
							millis())
						;;
					show_menu = 1;
					return;
				}

			}

		}

		millis_counter = millis();
		for (ul = millis_counter; ul < millis_counter + 3000; ul = millis())
			;;
		//display.clearDisplay();
		return;
	}
}

void ler_file_2() {

	myFile = SD.open(filename_box_tag);
	String last_reading;
	if (myFile) {

		// read from the file until there's nothing else in it:
		Serial.print("\nlendo do ficheiro2 as tags que sao de caixa:");
		while (myFile.available()) {
			//lastpos_file2 = myFile.position();

			if (file_counter_2 > 0)
				//last_column=myFile.readString();
				file2_tags[file_counter_2] = myFile.readStringUntil('\n'); // para ler x
			lastpos_file2 = myFile.position();
			file2_tags[file_counter_2] = file2_tags[file_counter_2].substring(0,
					5);

			////////////////////////////////////////////////////
			if (file_counter_2 > 0
					&& file2_tags[file_counter_2].length() == 0) {
				//lastpos_file2 = myFile.position();
			}
			if (file_counter_2 > 0
					&& file2_tags[file_counter_2].length() == 5) {
				//lastpos_file2 = myFile.position();
				last_reading = file2_tags[file_counter_2];
			}

			file_counter_2++;

		}
		myFile.close();
		Serial.print("\nUltima posicao do ficheiro2:");
		Serial.print(last_reading);

		Serial.print("\n:Posicao:");
		Serial.print(lastpos_file2);

		imprimir_file2();
	}

}

void update_ler_file2() {

	myFile = SD.open(filename_box_tag);
	String last_reading;
	if (myFile) {
		while (myFile.available()) {

			if (file_counter_2 > 0)

				file2_tags[file_counter_2] = myFile.readStringUntil('\n'); // para ler x
			lastpos_file2 = myFile.position();
			file2_tags[file_counter_2] = file2_tags[file_counter_2].substring(0,
					5);

			if (file_counter_2 > 0
					&& file2_tags[file_counter_2].length() == 0) {

			}
			if (file_counter_2 > 0
					&& file2_tags[file_counter_2].length() == 5) {

				last_reading = file2_tags[file_counter_2];
			}

			file_counter_2++;

		}
		myFile.close();
		//imprimir_file2();
	}

}
int ler_end_of_file_2() {

	int pos = 0;
	myFile = SD.open(filename_box_tag);

	if (myFile) {

		while (myFile.available()) {

			pos = myFile.position();
			last_column = myFile.readStringUntil('\n');
		}
		myFile.close();

	}
	Serial.print("\nUltima posicao do ficheiro2:");
	Serial.print(last_column);
	Serial.print("\n:Posicao:");
	Serial.print(pos);
	return pos;
}
void inserirBox_file_2(String current_reading) {

	update_ler_file2();
	int check = 0;
	if (current_reading.length() != 0) {
		for (int j = 0; j < file_counter_2; j++) {
			if (current_reading == file2_tags[j]) {
				if (current_reading.length() != 0)
					Serial.print(

					"\nTag ja inserida no sistema e corresponde a uma caixa ");
				check = 1;
			} else if (current_reading != file2_tags[j]
					&& (j == file_counter_2 - 1) && check != 1) {
				check = 1;
				file_counter_2++;
				file2_tags[file_counter_2] = current_reading;
				myFile = SD.open(filename_box_tag, FILE_WRITE);
				if (myFile) {
					myFile.seek(lastpos_file2);
					//	myFile.print('\n');
					myFile.println(current_reading);
					Serial.print("\nA tag lida:");
					Serial.print(current_reading);
					Serial.print(
							"\nfoi registada como tag de caixa no ficheiro 2!");
					myFile.close();
				}

				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.print("Tag lida:");
				display.print(current_reading);
				display.setCursor(0, 7);
				display.print(" foi adicionada");

				display.setCursor(0, 14);
				display.print("como tag caixa");
				display.setCursor(0, 21);
				display.print("com sucesso");
				display.display();
				millis_counter = millis();
				for (ul = millis_counter; ul < millis_counter + 3000; ul =
						millis())
					;;
			}
		}
	} else
		Serial.print("nao ha tags lidas");
}

String Inserir_tag_main_() {
	Serial.print(
			"\nInserir tag de caixa a que se pretende associar numa nova tag");
	String current_reading;
	card = RFID.A_single_poll_of_instructions();
	current_reading = card._EPC;
	current_reading = current_reading.substring(19, 24);
	if (current_reading.length() != 0) {
		Serial.print(
				"\n --------------------------TAG LIDA------------------------ ");
		Serial.print(current_reading); // 00-99
		Serial.print(
				"\n -------------------------- FIM DA LEITURA------------------------ ");
		RFID.clean_data();
		return current_reading;
	}
	Serial.print(
			"\n -------------------------- TAG NAO LIDA------------------------ ");
	RFID.clean_data();
}
void Inserir_tag_nova_() {
	int check = 0;
	char new_tag[6];
	char tag_main[6];
	String reading_main;
	String reading;

	int check_main = 0;
	int escolha = 0;

	Serial.print(
			"\n Colocar a tag nova a inserir no leitor e pressionar o botão 1 para ler");

	display.clearDisplay();
	display.setTextSize(0.5);
	display.setTextColor(SSD1306_WHITE);
	display.setCursor(0, 0);
	display.print("colocar tag a");
	display.setCursor(0, 7);
	display.print("registar no");
	display.setCursor(0, 14);
	display.print("leitor e permir");
	display.setCursor(0, 21);
	display.print("o botao 1");
	display.display();

	while (escolha != 1 || escolha != 2) {
		escolha = menu_select_all();
		if (escolha == 1 || escolha == 2) {
			break;
		}

	}
	millis_counter = millis();
	for (ul = millis_counter; ul < millis_counter + 1000; ul = millis())
		;;
	if (escolha == 1) {
		display.clearDisplay();
		display.setTextSize(0.5);
		display.setTextColor(SSD1306_WHITE);
		display.setCursor(0, 0);
		display.print("Aguardando leitura");
		display.print(reading);
		display.setCursor(0, 7);
		display.print("da tag");

		while (reading.length() == 0) {

			reading = func_adicionar_novas_tags();

		}

		check = 0;
		escolha = 0;
		Serial.print("\nTag lida:");

		Serial.print(reading);
		Serial.print("Pretende confirmar insercao 1-Sim  2-Nao");

		display.clearDisplay();
		display.setTextSize(0.5);
		display.setTextColor(SSD1306_WHITE);
		display.setCursor(0, 0);
		display.print("tag lida:");
		display.print(reading);
		display.setCursor(0, 7);
		display.print("pretende registar?");
		display.setCursor(0, 14);
		display.print("1-Sim");
		display.setCursor(0, 21);
		display.print("2-Voltar ao menu");

		display.display();
		while (escolha != 1 || escolha != 2) {
			escolha = menu_select_all();
			if (escolha == 1 || escolha == 2) {
				break;
			}
		}
		if (escolha == 1) {
			reading.toCharArray(new_tag, 6);

			myFile = SD.open(filename_box_tag);
			if (myFile) {

				if (myFile.find(new_tag)) {
					check = 1;
					myFile.close();

				}

			}

			if (check == 0) {

				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.print("tag lida:");
				display.print(reading);
				display.setCursor(0, 7);
				display.setCursor(0, 14);
				display.print("valida para ");
				display.setCursor(0, 21);
				display.print("registo");
				display.display();

				millis_counter = millis();
				for (ul = millis_counter; ul < millis_counter + 3000; ul =
						millis())
					;;

				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.print("Pretende continuar?");

				display.setCursor(0, 7);
				display.print("1-Ler tag de caixa ");
				;
				display.setCursor(0, 14);
				display.print("a associar");
				display.setCursor(0, 21);
				display.print("2-Voltar ao menu");
				display.display();

				escolha = 0;
				while (escolha != 1 || escolha != 2) {
					escolha = menu_select_all();
					if (escolha == 1 || escolha == 2) {
						break;
					}
				}
				if (escolha == 1) {


					display.clearDisplay();
					display.setTextSize(0.5);
					display.setTextColor(SSD1306_WHITE);
					display.setCursor(0, 0);
					display.print("Colocar tag de ");
					display.setCursor(0, 7);
					display.print("caixa no leitor");
					display.setCursor(0, 14);
					display.print("e premir 1-Avancar");
					display.setCursor(0, 21);
					display.print("2-Voltar menu");
					display.display();

					while (reading_main.length() == 0) {
						reading_main = func_adicionar_novas_tags();

					}
					for (int j = 0; j < file_counter_2; j++) {
						if (reading_main == file2_tags[j]) {

							check_main = 1;
							display.clearDisplay();
							display.setTextSize(0.5);
							display.setTextColor(SSD1306_WHITE);
							display.setCursor(0, 0);
							display.print("tag de caixa:");
							display.print(reading_main);
							display.setCursor(0, 7);
							display.print("valida para associacao ");

							display.setCursor(0, 14);
							display.print("1-Conformar associacao");

							display.setCursor(0, 21);
							display.print("2-Voltar para o menu");
							display.display();
							for (ul = millis_counter;
									ul < millis_counter + 2000; ul = millis())
								;;
							escolha = 0;

							while ((escolha != 1 || escolha != 2)) {

								escolha = menu_select_all();
								if (escolha == 1 || escolha == 2)
									break;
							}
							if (escolha == 1) {

								Serial.print("PONTO3333333333333333333");
								put_on_line(reading, reading_main);
								Serial.print(reading_main);

								display.clearDisplay();
								display.setTextSize(0.5);
								display.setTextColor(SSD1306_WHITE);
								display.setCursor(0, 0);
								display.print("tag nova: ");
								display.print(reading);
								display.setCursor(0, 7);
								display.print("adicionada com ");

								display.setCursor(0, 14);
								display.print("sucesso na caixa");

								display.setCursor(0, 21);
								display.print(reading_main);
								display.display();

								millis_counter = millis();
								for (ul = millis_counter;
										ul < millis_counter + 5000; ul =
												millis())
									;;
								display.clearDisplay();
								return;
							}
						} else if (j == file_counter_2 - 1 && check_main == 0) {
							Serial.print("PONTO33333333333333333333333333");
							display.clearDisplay();
							display.setTextSize(0.5);
							display.setTextColor(SSD1306_WHITE);
							display.setCursor(0, 0);
							display.print("tag de caixa:");
							display.print(reading_main);
							display.setCursor(0, 7);
							display.print("nao se encontra");

							display.setCursor(0, 14);

							display.print("no sistema ");

							display.setCursor(0, 21);
							display.print("operacao cancelada");
							display.display();

							Serial.print("\n tag nova: ");
							Serial.print(reading);
							Serial.print("\n associada a tag");
							Serial.print(tag_main);
							Serial.print("\n com sucesso");
							Serial.print(
									"\n a segunda tag de caixa lida nao se encontra no sistema ou nao e uma tag correspondente a caixa para associar:");

							Serial.print("\n Voltar ao menu inicial");
							millis_counter = millis();
							for (ul = millis_counter;
									ul < millis_counter + 5000; ul = millis())
								;;

							return;

						}

					}
				} else if (escolha == 2) {
					display.clearDisplay();
					display.setTextSize(0.5);
					display.setTextColor(SSD1306_WHITE);
					display.setCursor(0, 0);
					display.print("Operacao cancelada!");
					display.print(reading_main);
					display.setCursor(0, 7);
					display.print("pelo utilizador");

					display.setCursor(0, 14);

					display.print("voltando ao menu ");
					display.display();

					Serial.print(
							"\nVoltar para o menu inicial sem processo de insercao concluido");
					millis_counter = millis();
					for (ul = millis_counter; ul < millis_counter + 2000; ul =
							millis())
						;;

					return;
				}

			} else if (check == 1) {
				display.clearDisplay();
				display.setTextSize(0.5);
				display.setTextColor(SSD1306_WHITE);
				display.setCursor(0, 0);
				display.print("operacao cancelada");
				display.setCursor(0, 7);
				display.print("tag lida:");
				display.print(reading);
				display.setCursor(0, 14);
				display.print("ja se encontra");
				display.setCursor(0, 21);
				display.print("no sistema");
				display.display();
				Serial.print(
						"\n Tag ja registada no sistema logo nao podera ser adicionada novamente!");
				Serial.print("\n voltar ao menu inicial");
				millis_counter = millis();
				for (ul = millis_counter; ul < millis_counter + 2000; ul =
						millis())
					;;
				return;

			}

		} else if (escolha == 2) {
			display.clearDisplay();
			display.setTextSize(0.5);
			display.setTextColor(SSD1306_WHITE);
			display.setCursor(0, 0);
			display.print("Operacao cancelada!");
			display.print(reading_main);
			display.setCursor(0, 7);
			display.print("voltar para o menu");

			display.setCursor(0, 14);

			display.print("principal ");
			display.display();
			Serial.print(
					"\nVoltar para o menu inicial sem processo de insercao concluido");
			millis_counter = millis();
			for (ul = millis_counter; ul < millis_counter + 2000; ul = millis())
				;;

			return;
		}

	}

}

void put_on_line(String tag_nova, String tag_main) { // para uma tag main adquirir as tags que lhe estao associadas

	int pos = 0;
	int count2 = 0;
	char *ptr;
	char char_array[6];
	char last_reading_char[6];
	String current_reading_2[30];
	String reading;
	String tag_main_2;
	String last_reading;
	String deletada;
	int pos2 = 0;

	tag_main_2 = tag_main;
	tag_main_2.toCharArray(char_array, 6);
	if (tag_nova.length() != 0 && tag_main.length() == 5) {
		Serial.print("\nInsercao da tag :");
		Serial.print(tag_nova);
		Serial.print("na caixa: ");
		Serial.print(char_array);
		myFile = SD.open(filename_box_tag, FILE_READ);
		if (myFile) {
			if (myFile.find(char_array)) {  // procura a tag main
				myFile.position();  // devolve a posiÃ§Ã£o
				while (myFile.available()) {
					reading = myFile.readStringUntil('\n');
					deletada = myFile.readStringUntil('\0');
					if (myFile.find('\n')) { // serve para assimuir apenas a 1Âª coluna - sai na primeira ','

						break;
					}
				}
			}

			char column[reading.length()];
			Serial.print("\n\nLinha completa da tag:");

			Serial.print(char_array);
			Serial.print(":\n");
			Serial.print(reading);
			Serial.print("\n\n-------------------------------------------");
			reading.toCharArray(column, reading.length());
			if (reading.length() > 5) {
				ptr = strtok(column, ",");
				while (ptr != NULL) {
					last_reading = ptr;

					ptr = strtok(NULL, ",");
				}

				last_reading.toCharArray(last_reading_char, 6);
			} else {
				last_reading = tag_main;
				last_reading.toCharArray(last_reading_char, 6);

				Serial.print(last_reading);

			}
			myFile = SD.open(filename_box_tag, FILE_READ);
			if (myFile) {

				if (myFile.find(last_reading_char)) {

					pos = myFile.position();

				}
				myFile.close();
				Serial.print(last_reading_char);
				myFile = SD.open(filename_box_tag, FILE_WRITE);

				if (myFile.seek(pos)) {
					myFile.print(',');
					myFile.println(tag_nova);

					myFile.print(deletada);

					if (myFile.seek(lastpos_file2)) {
						String teste = myFile.readStringUntil('\n');
						Serial.print(teste);
						myFile.position();
						myFile.close();

					}

				}
				myFile.close();

				Serial.print("\nA ultima tag lida:");
				Serial.print(last_reading_char);
				Serial.print("\n");

			}

		}

	}

}

void imprimir_file1() {
	if (file_counter_1 != 0) {

		Serial.print("\nTags main registadas no ficheiro 1:");

		for (int i = 0; i < file_counter_1; i++) {
			Serial.print("\n");
			Serial.print(file1_tags[i]);

		}

	}
}

void imprimir_file2() {
	if (file_counter_2 != 0) {

		Serial.print("\nTags main registadas no ficheiro 2:");

		for (int i = 0; i < file_counter_2; i++) {
			Serial.print("\n");
			Serial.print(file2_tags[i]);

		}
		Serial.print("\nultima coluna");
		Serial.print(last_column);
	}

}
void write_sd() {
	myFile = SD.open(filename_tags, FILE_WRITE);

	if (myFile) {

// read from the file until there's nothing else in it:

		Serial.print("\n\nWriting to file1...");
		myFile.print("0101a,928ff,0d825");
		myFile.close();

	}

	myFile = SD.open(filename_box_tag, FILE_WRITE);
	if (myFile) {

// read from the file until there's nothing else in it:

		Serial.print("\n\nWriting to file2...");

		myFile.println("0101a,017bc");
		myFile.println("928ff,11003,00d57,0c97c,0c4ff,64763,00ebd,04768,64795");
		myFile.println("0d825");

		myFile.close();
	}
	show_menu = 1;
}

int http_get_message() {
	int button = 0;
	if (WiFi.status() == WL_CONNECTED) {  //Check WiFi connection status

		http.begin(server_menu_select);  //Specify destination for HTTP request
		//http.addHeader("Content-Type","application/json" );             //Specify content-type header

		int httpResponseCode = http.GET();		//Send the actual POST request

		if (httpResponseCode > 0) {
			String response = http.getString(); //Get the response to the request

			//Serial.println("RESPOSTAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA");   //Print return code
			Serial.println(response); //Print request answer

			if (response == "verificar_caixa") {
				button = 1;
				return button;
			}

			else if (response == "adicionar_caixa") {
				button = 2;
				return button;
			}

			else if (response == "adicionar_tag") {
				button = 3;
				return button;
			}

			Serial.println("\nResponse from Node-red:");
			Serial.println(response);
			Serial.println(button);
			http.end();

			return button;
		} else {
			http.end();
			return 0;
		}

	} else {

		Serial.print("Error on Wifi connection! ");

	}

	http.end();
	return 0;
}

void menu_select_keyboard_() {
	select_key = 0;
	char key = keypad.getKey();
//int user_menu = User_menu_input();

	if (key == '1')
		select_key = 1;
	else if (key == '2')
		select_key = 2;
	else if (key == '3')
		select_key = 3;
	else if (key == '4')
		select_key = 4;
	else if (key == '5')
		select_key = 5;

	else if (key == '6')
		select_key = 6;

//Serial.println(select_key);

}

int menu_select_all() {
	int user_menu = 0;
	int http_menu = 0;
	int selection = 0;
	user_menu = User_menu_input();
	menu_select_keyboard_();
	if (show_menu == 1) {
		show_menu = 0;
		Serial.println(commands_str);

	}

	if (button_change == 0) {
		http_menu = http_get_message();
		select_key = 0;
	}
	selection = 0;

	if (user_menu == 1 || http_menu == 1 || select_key == 1)
		selection = 1;
	else if (user_menu == 2 || http_menu == 2 || select_key == 2)
		selection = 2;
	else if (user_menu == 3 || http_menu == 3 || select_key == 3)
		selection = 3;
	else if (user_menu == 4 || http_menu == 4 || select_key == 4)
		selection = 4;
	else if (user_menu == 5 || http_menu == 5 || select_key == 5)
		selection = 5;
	else if (user_menu == 6 || http_menu == 6 || select_key == 6)
		selection = 6;
	else {
		selection = 0;
	}
	user_menu = 0;
	select_key = 0;
	http_menu = 0;

	for (ul = millis_counter; ul < millis_counter + 1000; ul = millis())
		;;
	return selection;
}


void mostrar_leitura() {
	show_menu = 1;
	int escolha = 0;

	display.clearDisplay();
	display.setTextSize(0.5);
	display.setTextColor(SSD1306_WHITE);
	display.setCursor(0, 0);
	display.print("Selecionar informacao");
	display.setCursor(0, 7);
	display.print("da ultima leitura");

	display.setCursor(0, 14);
	display.print("1-tags presentes ");

	display.setCursor(0, 21);

	display.print("2-tags em falta  ");

	display.display();

//escolha = menu_select_keyboard_();
	escolha = menu_select_all();
	while (escolha == 0) {

		escolha = menu_select_all();
		if (escolha == 1) {
			escolha = 0;
			display.clearDisplay();
			display.setTextSize(0.5);
			display.setTextColor(SSD1306_WHITE);
			display.setCursor(0, 0);
			display.print("tags lidas da caixa:");
			display.setCursor(0, 7);
			display.print(last_tag_main);

			display.setCursor(0, 14);
			display.print("Premir o botao 1 ");

			display.setCursor(0, 21);

			display.print("para sair ");

			display.display();
			lcd.clear();

			lcd.setCursor(0, 0);
			lcd.print(all_present_tags.substring(1, 12));
			lcd.setCursor(0, 1);
			lcd.print(all_present_tags.substring(13, 24));
			if (all_present_tags.length() > 32) {

				lcd.clear();

				lcd.setCursor(0, 0);
				lcd.print(all_present_tags.substring(25, 34));
				lcd.setCursor(0, 1);
				lcd.print(all_present_tags.substring(35, 46));

			}
			while (escolha == 0) {

				escolha = menu_select_all();
				if (escolha == 1) {
					Serial.print("\nVoltar atras");
					show_menu = 1;
					return;
				}
			}

		} else if (escolha == 2) {
			show_menu = 1;
			display.clearDisplay();
			display.setTextSize(0.5);
			display.setTextColor(SSD1306_WHITE);
			display.setCursor(0, 0);
			display.print("tags em falta da caixa:");
			display.setCursor(0, 7);
			display.print(last_tag_main);

			display.setCursor(0, 14);
			display.print("Premir o botao 1 ");

			display.setCursor(0, 21);

			display.print("para sair ");

			display.display();
			lcd.clear();

			lcd.setCursor(0, 0);
			lcd.print(all_missing_tags.substring(1, 16));
			lcd.setCursor(0, 1);
			lcd.print(all_missing_tags.substring(17, 32));

			millis_counter = millis();
			for (ul = millis_counter; ul < millis_counter + 1000; ul = millis())
				;;
			return;
			while (escolha == 0) {

				escolha = menu_select_all();
				if (escolha == 1) {
					Serial.print("\nVoltar atras");
					return;
				}
			}
		}
	}
}

void menu_change() {

	if (button_change == 1) {
	button_change=0;
	}
	else{
		button_change=1;
	}
}

void send_tags(){
	String c="";

	cards = RFID.Multiple_polling_instructions(20);
	size_t num=cards.len;
		for (size_t i = 0; i < num; i++) {
			String tag=cards.card[i]._EPC;
			c=c+","+tag.substring(19.24);

		}
		 RFID.clean_data();
		 http.begin(adicionar_tag_andre);
			 //http.addHeader("tag_principal", "text/plain");
			 http.POST(c);
			 http.end();
			 RFID.clean_data();
}
